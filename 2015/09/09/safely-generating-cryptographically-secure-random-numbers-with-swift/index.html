<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Safely Generating Cryptographically Secure Random Numbers With Swift - 0x42</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="http://jamescarroll.xyz/2015/09/09/safely-generating-cryptographically-secure-random-numbers-with-swift">

  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="http://jamescarroll.xyz/css/combined-min.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://jamescarroll.xyz" class="site-title">0x42</a>
      <nav class="site-nav right">
      <a href="http://jamescarroll.xyz/about/">About</a>
<a href="http://jamescarroll.xyz/tags">Tags</a>
<a href="http://jamescarroll.xyz/contact/">Contact</a>

<form class="navbar-search" action="http://jamescarroll.xyz/search/index.html"
    onsubmit="return validateForm(this.elements['q'].value);">
    <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">

</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">Safely Generating Cryptographically Secure Random Numbers With Swift</h1>
        <span class="post-meta">Sep 9, 2015 by James Carroll</span><br>
        
      </div>

      <article class="post-content">
      

<p>Apple has provided a function called <code>SecRandomCopyBytes()</code> inside their Security framework that allows us to create an <a href="https://developer.apple.com/library/ios/documentation/Security/Reference/RandomizationReference/#//apple_ref/c/func/SecRandomCopyBytes"><em>array</em> of cryptographically secure random bytes</a>. There are other ways to generate random data on iOS and OS X, most notably, <code>arc4random()</code> but this has a few problem: (1) <code>arc4random()</code> can only generate, at most, a 32 bit integer, (2) Apple&rsquo;s <code>arc4random()</code> isn&rsquo;t secure because <code>arc4random()</code> relies on an underlining <a href="https://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a> to achieve secure random data; Apple&rsquo;s <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/arc4random.3.html">implementation</a> uses <a href="https://en.wikipedia.org/wiki/RC4">RC4</a>, which is now considered <a href="http://blog.cryptographyengineering.com/2013/03/attack-of-week-rc4-is-kind-of-broken-in.html">broken</a>. SecRandomCopyBytes uses <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/rng/BlockCipherDRBGs.pdf">CTR_DRBG</a> which is still secure.</p>

<p>So now you know a little bit about why we want to use <code>SecRandomCopyBytes()</code>. We will be using Swift 2* to access <code>SecRandomCopyBytes()</code> without using <code>withUnsafeMutablePointer()</code> and <code>unsafeBitCast()</code>. Lets begin by looking at some <a href="https://developer.apple.com/library/ios/documentation/Security/Reference/RandomizationReference/#//apple_ref/c/func/SecRandomCopyBytes">docs</a>&hellip;</p>

<pre><code class="language-swift">// Obj-C
int SecRandomCopyBytes ( SecRandomRef rnd, size_t count, uint8_t *bytes ); 

// Swift
func SecRandomCopyBytes(_ rnd: SecRandomRef,
                      _ count: Int,
                      _ bytes: UnsafeMutablePointer&lt;UInt8&gt;) -&gt; Int32
</code></pre>

<p><code>rnd</code> is the random number generator (RNG) object to use. <code>kSecRandomDefault</code> is the default RNG.</p>

<p><code>count</code> is the number of bytes to return in the <em>array</em> pointed to by the <code>bytes</code> parameter.</p>

<p><code>bytes</code> is the random bytes generated by the function.</p>

<h2 id="objective-c:13e768278039e1819a22e060a3b8fd1b">Objective-C</h2>

<pre><code>// Obj-C
@import Security;

uint32_t randomNum = 0; 
SecRandomCopyBytes(kSecRandomDefault, 4, (uint8_t*) &amp;randomNum);
</code></pre>

<p>First, we declared an unsigned 32-bit integer and initialized it to 0. Next, we call SecRandomCopyBytes passing 4 as the number of bytes (4 bytes, 32 bits), as well as the address of the <code>randomNum</code> integer we just declared. Awesome.</p>

<h2 id="swift-first-attempt:13e768278039e1819a22e060a3b8fd1b">Swift, First Attempt</h2>

<pre><code class="language-swift">// Swift
import Security

var randomNum: UInt32 = 0
SecRandomCopyBytes(kSecRandomDefault, 4, &amp;randomNum)
</code></pre>

<p>This won&rsquo;t work. A compiler error is generated because UInt32 is not the same as UInt8. Yay for strongly typed languages! (Seriously though, I think they&rsquo;re great.)</p>

<h2 id="swift-playing-it-safe:13e768278039e1819a22e060a3b8fd1b">Swift, Playing it Safe</h2>

<pre><code class="language-swift">// Swift 
import Security

let bytesCount = 4 // number of bytes
var randomNum: UInt32 = 0 // variable for random unsigned 32 bit integer
var randomBytes = [UInt8](count: bytesCount, repeatedValue: 0) // array to hold randoms bytes

// Gen random bytes
SecRandomCopyBytes(kSecRandomDefault, bytesCount, &amp;randomBytes)

// Turn bytes into data and pass data bytes into int
NSData(bytes: randomBytes, length: bytesCount).getBytes(&amp;randomNum, length: bytesCount)
</code></pre>

<p>So what&rsquo;s going on here? First, we initialize a variable for the number of bytes we want to use (4 bytes, 32 bits). Next, we initialize a variable for the random number we&rsquo;re trying to generate and we initialize an array to hold the random bytes. Then, we can call <code>SecRandomCopyBytes()</code> passing in the default RNG, the number of bytes we want to generate, and the address to the array of bytes. Finally, we create a NSData object based on the array of bytes and we get the bytes ( <code>.getBytes()</code> ) by passing in the address where the bytes will be going (which is an unsigned 32 bit int in our case) and the number of bytes. <code>randomNum</code> now has 32 bits of random data.</p>

<p>Awesome! We&rsquo;re done now, right? Not quite. The method above work if we want a random integer but this limits us to 64 bit numbers. What happens when we want 128 or 256 bit numbers? Lets take a look (hint: hexadecimal string).</p>

<h2 id="swift-playing-it-safe-with-large-numbers:13e768278039e1819a22e060a3b8fd1b">Swift, Playing it Safe With Large Numbers</h2>

<pre><code class="language-swift">// Swift 
import Security

let bytesCount = 32 // number of bytes
var randomNum = &quot;&quot; // hexadecimal version of randomBytes
var randomBytes = [UInt8](count: bytesCount, repeatedValue: 0) // array to hold randoms bytes

// Gen random bytes
SecRandomCopyBytes(kSecRandomDefault, bytesCount, &amp;randomBytes)

// Turn randomBytes into array of hexadecimal strings
// Join array of strings into single string
randomNum = randomBytes.map({String(format: &quot;%02hhx&quot;, $0)}).joinWithSeparator(&quot;&quot;)
</code></pre>

<p>Here we&rsquo;re using a string to hold a hexadecimal representation of a 256 bit number. Instead of using <code>NSData()</code> we turn <code>randomBytes</code> into an array of hexadecimal strings. We use the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html">string formatter</a> <code>&quot;%02hhx&quot;</code> to turn our byte (denoted <code>$0</code>) into a hex representation. Lastly, we join the array of strings into a single string using <code>.joinWithSeparator()</code> Awesome! Now we know how to generate cyrptographically secure random integers and hexadecimal strings.</p>

<h2 id="wrapping-up:13e768278039e1819a22e060a3b8fd1b">Wrapping Up</h2>

<p>I hope you learn something here, I know I have while researching iOS security. Swift has also become my favorite language and really love writing code in it.  I can&rsquo;t wait to see how Swift develops as an open source language.  Thanks for reading.</p>

<p>Follow me on <a href="https://twitter.com/jamcar23">twitter</a> for more!</p>

<p><em>Notes:</em></p>

<p>*The <code>SecRandomCopyBytes()</code> call works the same way in  Swift 1.2 but some of the other syntax has changed in Swift 2, example: <code>String.join([String])</code> has become <code>[String].joinWithSeparator(&quot;&quot;)</code>.</p>

      </article>

      <p class="post-meta">Tags:&nbsp;
        
            
            <a href="http://jamescarroll.xyz/tags/swift">swift</a>
        
            ,&nbsp;
            <a href="http://jamescarroll.xyz/tags/swift%202">swift 2</a>
        
            ,&nbsp;
            <a href="http://jamescarroll.xyz/tags/iOS">iOS</a>
        
            ,&nbsp;
            <a href="http://jamescarroll.xyz/tags/crypto">crypto</a>
        
            ,&nbsp;
            <a href="http://jamescarroll.xyz/tags/random%20numbers">random numbers</a>
        
      </p>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="http://jamescarroll.xyz/index.xml"></a>

<a class="fa fa-twitter twitter" href="https://twitter.com/jamcar23"></a>

</nav>

          <small>
            Copyright &#169; 2015<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>

    
    <script src="http://jamescarroll.xyz/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    


</body>
</html>

